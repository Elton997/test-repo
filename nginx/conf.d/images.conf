# Image Resize Configuration
# Supports real-time image resizing via URL patterns
# Usage: /images/{width}/{height}/{filename}
# Example: /images/100/100/device_image.jpg
# 
# If no width/height parameters are provided, returns the original image
# Note: Nginx image_filter module has limitations with dynamic dimensions.
# This configuration proxies to backend for actual resizing, or serves original.

# Cache zone for resized images
proxy_cache_path /tmp/nginx_image_cache levels=1:2 keys_zone=image_cache:10m max_size=100m inactive=60m use_temp_path=off;

# Image resize location - Pattern: /images/{width}/{height}/{filename}
location ~* ^/images/(\d+)/(\d+)/(.+\.(jpg|jpeg|png|gif|webp))$ {
    set $width $1;
    set $height $2;
    set $image_file $3;
    
    # Validate dimensions (must be > 0)
    if ($width = "0") {
        return 400 "Width must be greater than 0";
    }
    if ($height = "0") {
        return 400 "Height must be greater than 0";
    }
    
    # Limit maximum dimensions (5000px)
    if ($width > 5000) {
        set $width 5000;
    }
    if ($height > 5000) {
        set $height 5000;
    }
    
    # Try to serve from local storage first
    root /app/static/device_images;
    try_files /$image_file @proxy_resize;
    
    # Serve with cache headers (backend will handle resize)
    expires 7d;
    add_header Cache-Control "public, immutable";
    add_header X-Image-Dimensions "${width}x${height}";
}

# Proxy to backend for image resizing
location @proxy_resize {
    internal;
    
    # Proxy to backend - backend should handle resizing
    # Note: Backend needs to implement resize endpoint or serve original
    proxy_pass http://backend_api/static/device_images/$image_file?width=$width&height=$height;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # Cache resized images
    proxy_cache image_cache;
    proxy_cache_valid 200 1h;
    proxy_cache_key "$scheme$request_method$host$request_uri";
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    add_header X-Cache-Status $upstream_cache_status;
    
    expires 7d;
    add_header Cache-Control "public, immutable";
    add_header X-Image-Dimensions "${width}x${height}";
}

# Serve original images (no resize) - Pattern: /images/{filename}
# This location handles images without resize dimensions
# Must come after the resize pattern to avoid conflicts
location ~* ^/images/([^/]+\.(jpg|jpeg|png|gif|webp))$ {
    set $image_file $1;
    
    # Serve original image from local storage
    root /app/static/device_images;
    try_files /$image_file @proxy_original;
    
    expires 30d;
    add_header Cache-Control "public, immutable";
    add_header X-Image-Original "true";
}

# Proxy original image (no resize)
location @proxy_original {
    internal;
    
    proxy_pass http://backend_api/static/device_images/$image_file;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    expires 30d;
    add_header Cache-Control "public, immutable";
    add_header X-Image-Original "true";
}

# Alternative pattern: /images/resize/{width}/{height}/{filename}
location ~* ^/images/resize/(\d+)/(\d+)/(.+)$ {
    rewrite ^/images/resize/(\d+)/(\d+)/(.+)$ /images/$1/$2/$3 permanent;
}

# Serve original images directly (without resizing) from /images/original/
location /images/original/ {
    alias /app/static/device_images/;
    expires 30d;
    add_header Cache-Control "public, immutable";
    
    location ~* \.(jpg|jpeg|png|gif|webp|svg|ico)$ {
        try_files $uri =404;
    }
    
    deny all;
}
